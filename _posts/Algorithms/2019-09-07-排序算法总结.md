### 排序算法对比

原址性
稳定性
空间复杂度
时间复杂度
适用范围
原理
步骤


|排序算法|最坏情况|最坏运行时间|最佳情况|最佳运行时间|期望运行时间|空间复杂度|原址排序|比较排序|稳定|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|插入排序|逆序|$\Theta \left( n^{2} \right)$|正序|$\Theta \left( n \right)$|$\Theta \left( n^{2} \right)$|$\mathbf{O} \left( 1 \right)$|是|是|是|
|归并排序||$\Theta \left( n \lg n \right)$||$\Theta \left( n \lg n \right)$|$\Theta \left( n \lg n \right)$|$\mathbf{O} \left( n \right)$|否|是|是|
|堆排序||$\mathbf{O} \left( n \lg n \right)$|||——|$\mathbf{O} \left( 1 \right)$|是|是|否|
|快速排序||$\Theta \left( n^{2} \right)$|||$\Theta\left( n \lg n \right)$|$\mathbf{O} \left( \lg n \right)$|是|是|否|
|计数排序||$\Theta \left( k + n \right)$|||$\Theta \left( k + n \right)$|$\mathbf{O} \left( k \right)$|否|否|是|
|基数排序||$\Theta \left( d \left( n + k \right) \right)$|||$\Theta \left( d \left( n + k \right) \right)$|$\mathbf{O} \left( n + k \right)$|否|否|是|
|桶排序||$\Theta\left( n^{2} \right)$|||$\Theta \left( n \right)$|$\mathbf{O} \left( n + k \right)$|否|否|是|

*稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面；*


- 在最坏情况下，任何比较排序算法都需要做 $\Omega \left( n \lg n \right)$ 次比较。
- 堆排序和归并排序都是渐进最优的比较排序是算法。


**链表：最坏情况下的仅仅运行时间**

|unsorted, singly linked|sorted, singly linked|unsorted, doubly linked|sorted, doubly linked|
|:---:|:---:|:---:|:---:|:---:|
|$\text{SEARCH(L, k)}$|$\Theta(n)$|$\Theta(n)$|$\Theta(n)$|$\Theta(n)$|
|$\text{INSERT(L, x)}$|$\Theta(1)$|$\Theta(n)$|$\Theta(1)$|$\Theta(n)$|
|$\text{DELETE(L, x)}$|$\Theta(n)$|$\Theta(n)$|$\Theta(1)$|$\Theta(1)$|
|$\text{SUCCESSOR(L, x)}$|$\Theta(n)$|$\Theta(1)$|$\Theta(n)$|$\Theta(1)$|
|$\text{PREDECESSOR(L, x)}$|$\Theta(n)$|$\Theta(n)$|$\Theta(n)$|$\Theta(1)$|
|$\text{MINIMUM(L)}$|$\Theta(n)$|$\Theta(1)$|$\Theta(n)$|$\Theta(1)$|
|$\text{MAXIMUM(L)}$|$\Theta(n)$|$\Theta(n)$|$\Theta(n)$|$\Theta(n)$|
